# Data Model: Constitution Compliance Implementation

**Feature**: Constitution Compliance Implementation
**Date**: 2025-11-13
**Phase**: Phase 1 - Entity Design
**Version**: 2.0.0

## Overview

This data model defines the entities, relationships, and validation rules required to implement and enforce Notio's Constitutional testing requirements. Unlike typical API features, this is a **testing infrastructure feature** that models test artifacts, coverage metrics, accessibility audits, and performance measurements.

The model supports:
- **Integration-first testing strategy**: 60-70% integration, 20-30% E2E, 10-20% unit tests
- **100% code coverage enforcement**: Line and branch coverage validation
- **WCAG 2.1 AA compliance tracking**: Accessibility violation detection and remediation
- **Performance validation**: Audio latency (<50ms), notation rendering (<200ms)
- **Musical feature testing**: Notation + audio + interaction integration testing

All entities are **runtime/file-system based** - no database required. Test runners (Jest, Playwright) and tools (axe-core) generate these entities, which are then validated against constitutional requirements.

---

## Core Entities

### Entity 1: TestSuite

**Description**: A collection of related tests organized by type (integration, E2E, unit, accessibility) with associated coverage metrics and execution metadata. Represents a logical grouping of tests that target a specific area of functionality.

**Fields**:
```typescript
interface TestSuite {
  id: string;                    // Unique identifier (e.g., "integration-musical-components")
  name: string;                  // Human-readable name (e.g., "Musical Components Integration Tests")
  type: TestType;                // "integration" | "e2e" | "unit" | "accessibility"
  testFiles: string[];           // Array of absolute file paths
  totalTests: number;            // Total number of test cases
  passedTests: number;           // Number of passed tests
  failedTests: number;           // Number of failed tests
  skippedTests: number;          // Number of skipped/pending tests
  executionTime: number;         // Total duration in milliseconds
  averageTestTime: number;       // Average time per test (ms)
  coverageMetrics: CoverageReport; // Associated coverage data
  lastRun: Date;                 // Timestamp of last execution
  status: SuiteStatus;           // "passing" | "failing" | "skipped" | "not-run"
  constitutionCompliance: {
    meetsPercentageTarget: boolean;  // Matches constitutional distribution
    meetsPerformanceTarget: boolean; // Tests complete within time limits
    percentageOfTotal: number;       // Percentage of total test suite
  };
}

type TestType = "integration" | "e2e" | "unit" | "accessibility";
type SuiteStatus = "passing" | "failing" | "skipped" | "not-run";
```

**Relationships**:
- **Has many** TestCase entities (one-to-many)
- **Has one** CoverageReport entity (one-to-one)
- **Belongs to** TestConfiguration (many-to-one)

**Validation Rules** (from FR-002, FR-003, FR-004, SC-002, SC-003, SC-004):
- Integration suites MUST account for 60-70% of total test count
- E2E suites MUST account for 20-30% of total test count
- Unit suites MUST account for 10-20% of total test count
- Integration test `averageTestTime` MUST be < 5000ms (5 seconds)
- E2E test `averageTestTime` MUST be < 30000ms (30 seconds)
- `status` MUST be "passing" before feature can be merged
- `totalTests` across all suites MUST achieve 100% code coverage

**State Transitions**:
```
not-run → running → passing/failing/skipped
passing → running (on re-execution)
failing → running (on re-execution)
skipped → running (when re-enabled)
```

**Derived Calculations**:
```javascript
averageTestTime = executionTime / totalTests;
constitutionCompliance.percentageOfTotal = (totalTests / globalTotalTests) * 100;
constitutionCompliance.meetsPerformanceTarget =
  (type === "integration" && averageTestTime < 5000) ||
  (type === "e2e" && averageTestTime < 30000) ||
  type === "unit";
```

**Implementation Notes**:
- Generated by Jest test results for integration/unit tests
- Generated by Playwright test results for E2E tests
- File paths should be relative to project root for portability
- Status is determined by `passedTests === totalTests && failedTests === 0`

---

### Entity 2: TestCase

**Description**: An individual test within a test suite representing a specific scenario, user workflow, or assertion. The atomic unit of testing that validates a single requirement or behavior.

**Fields**:
```typescript
interface TestCase {
  id: string;                    // Unique identifier
  name: string;                  // Test description (e.g., "should synchronize audio playback with notation")
  filePath: string;              // Location of test file (absolute path)
  suiteType: TestType;           // "integration" | "e2e" | "unit" | "accessibility"
  status: TestStatus;            // "passed" | "failed" | "skipped" | "pending" | "running"
  executionTime: number;         // Duration in milliseconds
  error: string | null;          // Error message if failed
  stackTrace: string | null;     // Stack trace if failed
  retryCount: number;            // Number of retries (for flaky test detection)
  maxRetries: number;            // Maximum allowed retries
  tags: string[];                // Categorization tags (e.g., ["audio", "notation", "user-interaction"])
  constitutionPrinciples: string[]; // Which principles this test validates (e.g., ["Principle I", "Principle V"])
  affectedComponents: string[];  // Components under test
  functionalRequirements: string[]; // FRs this test validates (e.g., ["FR-008", "FR-015"])
  successCriteria: string[];     // SCs this test validates (e.g., ["SC-005", "SC-012"])
  testType: {
    isIntegration: boolean;
    isE2E: boolean;
    isUnit: boolean;
    coversUserWorkflow: boolean;  // Does this test a complete user journey?
    coversEdgeCase: boolean;      // Is this testing an edge case?
  };
}

type TestStatus = "passed" | "failed" | "skipped" | "pending" | "running";
```

**Relationships**:
- **Belongs to** one TestSuite (many-to-one)
- **References** one or more ComponentUnderTest (many-to-many)
- **Validates** one or more FunctionalRequirements (many-to-many, conceptual)

**Validation Rules** (from FR-003, FR-004, SC-003, SC-004):
- Integration tests: `executionTime` MUST be < 5000ms
- E2E tests: `executionTime` MUST be < 30000ms
- Unit tests: No strict time limit but should be fast (<100ms recommended)
- `retryCount` SHOULD be <= 2 (flaky tests beyond 2 retries indicate test quality issues)
- `constitutionPrinciples` MUST NOT be empty (every test validates at least one principle)
- `functionalRequirements` MUST NOT be empty (every test validates at least one FR)
- Tests with `status === "failed"` MUST block CI/CD pipeline

**State Transitions**:
```
pending → running → passed/failed/skipped
failed → running (on retry, if retryCount < maxRetries)
skipped → running (when re-enabled)
passed → running (on re-execution)
```

**Example Test Case Mappings**:

**Integration Test Example** (FR-008, SC-012):
```javascript
{
  id: "int-001-audio-notation-sync",
  name: "should synchronize audio playback with visual notation highlighting",
  filePath: "/src/__integration__/musical-features/audio-notation.test.js",
  suiteType: "integration",
  status: "passed",
  executionTime: 3200,
  tags: ["audio", "notation", "synchronization", "tone.js", "vexflow"],
  constitutionPrinciples: ["Principle I", "Principle V", "Principle IV"],
  functionalRequirements: ["FR-008", "FR-015"],
  successCriteria: ["SC-012", "SC-005"],
  testType: {
    isIntegration: true,
    coversUserWorkflow: true,
    coversEdgeCase: false
  }
}
```

**E2E Test Example** (FR-009, SC-013):
```javascript
{
  id: "e2e-001-student-exercise-completion",
  name: "Student completes full exercise from landing page to submission",
  filePath: "/e2e/student-workflows/complete-exercise.spec.js",
  suiteType: "e2e",
  status: "passed",
  executionTime: 28400,
  tags: ["student-workflow", "end-to-end", "critical-path"],
  constitutionPrinciples: ["Principle III", "Principle V"],
  functionalRequirements: ["FR-009"],
  successCriteria: ["SC-013"],
  testType: {
    isE2E: true,
    coversUserWorkflow: true,
    coversEdgeCase: false
  }
}
```

**Unit Test Example** (FR-002, SC-002):
```javascript
{
  id: "unit-001-interval-calculation-edge-cases",
  name: "calculates musical intervals correctly for compound intervals and edge cases",
  filePath: "/src/lib/music-theory/__tests__/intervals.test.js",
  suiteType: "unit",
  status: "passed",
  executionTime: 45,
  tags: ["music-theory", "intervals", "edge-cases", "algorithms"],
  constitutionPrinciples: ["Principle I"],
  functionalRequirements: ["FR-002"],
  successCriteria: ["SC-002"],
  testType: {
    isUnit: true,
    coversUserWorkflow: false,
    coversEdgeCase: true
  }
}
```

---

### Entity 3: CoverageReport

**Description**: Comprehensive code coverage metrics generated by test execution, tracking line, branch, function, and statement coverage. Enforces the constitutional requirement of 100% code coverage.

**Fields**:
```typescript
interface CoverageReport {
  id: string;                    // Unique identifier
  timestamp: Date;               // When report was generated

  // Line coverage
  totalLines: number;            // Total lines of code
  coveredLines: number;          // Lines covered by tests
  lineCoverage: number;          // Percentage (coveredLines / totalLines * 100)

  // Branch coverage
  totalBranches: number;         // Total conditional branches
  coveredBranches: number;       // Branches covered by tests
  branchCoverage: number;        // Percentage (coveredBranches / totalBranches * 100)

  // Function coverage
  totalFunctions: number;        // Total functions
  coveredFunctions: number;      // Functions covered by tests
  functionCoverage: number;      // Percentage

  // Statement coverage
  totalStatements: number;       // Total statements
  coveredStatements: number;     // Statements covered by tests
  statementCoverage: number;     // Percentage

  // Uncovered code tracking
  uncoveredFiles: Array<{
    filePath: string;
    lineCoverage: number;
    branchCoverage: number;
    uncoveredLines: number[];
    uncoveredBranches: number[];
  }>;

  // Test distribution (constitutional requirement)
  testDistribution: {
    integration: {
      count: number;
      percentage: number;         // Must be 60-70%
      coverageContribution: number; // % of coverage from integration tests
    };
    e2e: {
      count: number;
      percentage: number;         // Must be 20-30%
      coverageContribution: number; // % of coverage from E2E tests
    };
    unit: {
      count: number;
      percentage: number;         // Must be 10-20%
      coverageContribution: number; // % of coverage from unit tests
    };
  };

  // Constitutional compliance
  constitutionCompliance: {
    meets100PercentTarget: boolean;      // lineCoverage >= 100 && branchCoverage >= 100
    meetsDistributionTarget: boolean;    // 60-70-20-30 distribution met
    violationReasons: string[];          // Why compliance failed (if applicable)
  };

  // CI/CD integration
  passesThreshold: boolean;      // All thresholds met (gates CI/CD)
  thresholds: {
    lines: number;               // Required: 100
    branches: number;            // Required: 100
    functions: number;           // Required: 100
    statements: number;          // Required: 100
  };
}
```

**Relationships**:
- **Belongs to** TestSuite(s) (one-to-many or aggregated)
- **Has many** FileCoverageDetail entities (one-to-many)

**Validation Rules** (from FR-001, FR-005, FR-018, SC-001):
- `lineCoverage` MUST be >= 100%
- `branchCoverage` MUST be >= 100%
- `functionCoverage` MUST be >= 100%
- `statementCoverage` MUST be >= 100%
- `testDistribution.integration.percentage` MUST be between 60-70%
- `testDistribution.e2e.percentage` MUST be between 20-30%
- `testDistribution.unit.percentage` MUST be between 10-20%
- `passesThreshold` MUST be true for CI/CD pipeline to pass
- `uncoveredFiles` MUST be empty array

**Derived Calculations**:
```javascript
// Line coverage
lineCoverage = (coveredLines / totalLines) * 100;

// Branch coverage
branchCoverage = (coveredBranches / totalBranches) * 100;

// Test distribution percentages
const totalTests = integration.count + e2e.count + unit.count;
testDistribution.integration.percentage = (integration.count / totalTests) * 100;
testDistribution.e2e.percentage = (e2e.count / totalTests) * 100;
testDistribution.unit.percentage = (unit.count / totalTests) * 100;

// Constitutional compliance
constitutionCompliance.meets100PercentTarget =
  lineCoverage >= 100 && branchCoverage >= 100;

constitutionCompliance.meetsDistributionTarget =
  testDistribution.integration.percentage >= 60 &&
  testDistribution.integration.percentage <= 70 &&
  testDistribution.e2e.percentage >= 20 &&
  testDistribution.e2e.percentage <= 30 &&
  testDistribution.unit.percentage >= 10 &&
  testDistribution.unit.percentage <= 20;

// Overall pass/fail
passesThreshold =
  lineCoverage >= thresholds.lines &&
  branchCoverage >= thresholds.branches &&
  functionCoverage >= thresholds.functions &&
  statementCoverage >= thresholds.statements &&
  constitutionCompliance.meets100PercentTarget &&
  constitutionCompliance.meetsDistributionTarget;
```

**Violation Reasons** (populated if compliance fails):
```javascript
const violationReasons = [];

if (lineCoverage < 100) {
  violationReasons.push(`Line coverage is ${lineCoverage.toFixed(2)}% (requires 100%)`);
}

if (branchCoverage < 100) {
  violationReasons.push(`Branch coverage is ${branchCoverage.toFixed(2)}% (requires 100%)`);
}

if (testDistribution.integration.percentage < 60) {
  violationReasons.push(
    `Integration tests are ${testDistribution.integration.percentage.toFixed(1)}% (requires 60-70%)`
  );
}

if (testDistribution.integration.percentage > 70) {
  violationReasons.push(
    `Integration tests are ${testDistribution.integration.percentage.toFixed(1)}% (max 70%, consider moving to E2E)`
  );
}

// ... similar for E2E and unit distributions
```

**Implementation Notes**:
- Generated by Jest's Istanbul/nyc coverage tool
- Stored in `/coverage/coverage-final.json`
- HTML report available at `/coverage/lcov-report/index.html`
- CI/CD pipeline reads `passesThreshold` to gate merges
- Test distribution calculated by counting tests in each directory structure

---

### Entity 4: FileCoverageDetail

**Description**: Granular coverage information for a single source file, tracking which specific lines, branches, functions, and statements are covered or uncovered by tests.

**Fields**:
```typescript
interface FileCoverageDetail {
  filePath: string;              // Absolute path to source file
  relativePath: string;          // Path relative to project root

  // Line coverage details
  lines: Record<number, number>; // Line number → hit count
  uncoveredLines: number[];      // Array of line numbers not covered
  lineCoverage: number;          // Percentage for this file

  // Branch coverage details
  branches: Record<string, {
    line: number;
    type: string;                // "if" | "switch" | "cond-expr" | "binary-expr"
    locations: Array<{
      start: { line: number; column: number };
      end: { line: number; column: number };
    }>;
    hits: number[];              // Hit count per branch path
  }>;
  uncoveredBranches: string[];   // Branch IDs not covered
  branchCoverage: number;        // Percentage for this file

  // Function coverage details
  functions: Record<string, {
    name: string;
    line: number;
    hits: number;
  }>;
  uncoveredFunctions: string[];  // Function names not covered
  functionCoverage: number;      // Percentage for this file

  // Statement coverage details
  statements: Record<number, number>; // Statement ID → hit count
  uncoveredStatements: number[]; // Statement IDs not covered
  statementCoverage: number;     // Percentage for this file

  // Metadata
  componentName: string | null;  // Component name (if React component)
  fileType: string;              // "component" | "utility" | "service" | "hook" | "test"
  linesOfCode: number;           // Total lines in file (including comments)
  executableLines: number;       // Lines that can be executed (excluding comments/blank)
}
```

**Relationships**:
- **Belongs to** one CoverageReport (many-to-one)
- **References** one ComponentUnderTest (one-to-one, if applicable)

**Validation Rules** (from FR-001, FR-018):
- `lineCoverage` MUST be >= 100% per file
- `branchCoverage` MUST be >= 100% per file
- `uncoveredLines` MUST be empty array
- `uncoveredBranches` MUST be empty array
- Files in `node_modules/` excluded from validation
- Test files (`*.test.js`, `*.spec.js`) excluded from validation

**Implementation Notes**:
- Generated by Istanbul/nyc as part of Jest coverage
- Stored in JSON format in `/coverage/coverage-final.json`
- Each file has entry in coverage-final.json with this structure
- Branch types correspond to Istanbul branch types
- Hit counts indicate how many times a line/branch/function was executed

**Example Structure** (from Istanbul):
```json
{
  "/absolute/path/to/src/components/ColorKey.js": {
    "path": "/absolute/path/to/src/components/ColorKey.js",
    "statementMap": { "0": { "start": { "line": 5, "column": 2 }, "end": { "line": 8, "column": 3 } } },
    "fnMap": { "0": { "name": "ColorKey", "line": 4 } },
    "branchMap": { "0": { "line": 10, "type": "if", "locations": [...] } },
    "s": { "0": 15 },  // Statement 0 hit 15 times
    "f": { "0": 15 },  // Function 0 hit 15 times
    "b": { "0": [10, 5] }  // Branch 0: path 0 hit 10 times, path 1 hit 5 times
  }
}
```

---

### Entity 5: ComponentUnderTest

**Description**: A React component being tested, with metadata about testability, reusability, accessibility compliance, and constitutional principle adherence. Central entity for tracking component-level compliance.

**Fields**:
```typescript
interface ComponentUnderTest {
  // Identification
  name: string;                  // Component name (e.g., "ColorKey", "TopMenu", "MusicalStaff")
  filePath: string;              // Absolute path to component file
  directory: string;             // Parent directory (e.g., "src/components/common/")

  // Component type and classification
  type: ComponentType;           // "presentational" | "container" | "utility" | "hook" | "hoc"
  isMusicalFeature: boolean;     // Does this component render/handle music?
  musicalCapabilities: string[]; // ["notation", "audio", "midi", "theory", "exercises"]

  // Constitutional Principle II: Component Reusability
  isReusable: boolean;           // Is component designed for reuse?
  isInCommonDirectory: boolean;  // Located in src/components/common/?
  hasSingleResponsibility: boolean; // Follows SRP?
  hasPropsDocumentation: boolean; // Props documented (TypeScript/PropTypes/JSDoc)?
  propsInterface: {
    propCount: number;
    requiredProps: string[];
    optionalProps: string[];
    hasDefaultProps: boolean;
    hasTypeChecking: boolean;    // TypeScript or PropTypes
  };
  compositionComplexity: {
    childComponentCount: number; // How many child components?
    nestingDepth: number;        // Max nesting level
    shouldDecompose: boolean;    // Is component too complex?
  };

  // Constitutional Principle VI: Accessibility
  isAccessible: boolean;         // WCAG 2.1 AA compliant?
  accessibilityViolations: AccessibilityViolation[]; // Array of violations
  accessibilityFeatures: {
    hasKeyboardNavigation: boolean;
    hasAriaLabels: boolean;
    meetsContrastRequirements: boolean;
    hasTextAlternatives: boolean;
    hasSemanticHTML: boolean;
  };

  // Test coverage (Constitutional Principle I)
  coverage: {
    integration: {
      testCount: number;
      coveragePercentage: number;
      testFiles: string[];
    };
    e2e: {
      testCount: number;
      coveragePercentage: number;
      testFiles: string[];
    };
    unit: {
      testCount: number;
      coveragePercentage: number;
      testFiles: string[];
    };
    total: {
      testCount: number;
      coveragePercentage: number; // Must be 100%
    };
  };

  // Constitutional compliance summary
  constitutionCompliance: {
    "Principle I": boolean;      // 100% test coverage
    "Principle II": boolean;     // Reusability standards
    "Principle III": boolean;    // Educational pedagogy (manual assessment)
    "Principle IV": boolean;     // Performance requirements
    "Principle V": boolean;      // Integration-first testing
    "Principle VI": boolean;     // Accessibility compliance
    "Principle VII": boolean;    // Simplicity and maintainability
    overallCompliant: boolean;   // All principles met
    violations: string[];        // Description of violations
  };

  // Dependencies
  dependencies: string[];        // npm packages this component depends on
  internalDependencies: string[]; // Other Notio components this depends on
  usedBy: string[];              // Components that use this component
}

type ComponentType = "presentational" | "container" | "utility" | "hook" | "hoc";
```

**Relationships**:
- **Has many** TestCase entities (one-to-many)
- **Has many** AccessibilityViolation entities (one-to-many)
- **Has one** FileCoverageDetail entity (one-to-one)
- **Has many** PerformanceMetric entities (one-to-many, if performance-critical)

**Validation Rules** (from FR-010, FR-011, FR-012, FR-014, SC-009):
- **Principle II Compliance**:
  - Reusable components: `isInCommonDirectory` MUST be true
  - `hasSingleResponsibility` MUST be true
  - `hasPropsDocumentation` MUST be true
  - `propsInterface.hasTypeChecking` MUST be true
  - If `compositionComplexity.shouldDecompose === true`, component MUST be refactored

- **Principle VI Compliance**:
  - `isAccessible` MUST be true
  - `accessibilityViolations.length` MUST be 0
  - `accessibilityFeatures.hasKeyboardNavigation` MUST be true
  - `accessibilityFeatures.meetsContrastRequirements` MUST be true

- **Principle I Compliance**:
  - `coverage.total.coveragePercentage` MUST be 100%
  - `coverage.integration.coveragePercentage` SHOULD be highest percentage

- **Overall**:
  - `constitutionCompliance.overallCompliant` MUST be true before component can be merged

**Derived Calculations**:
```javascript
// Total test count
coverage.total.testCount =
  coverage.integration.testCount +
  coverage.e2e.testCount +
  coverage.unit.testCount;

// Is component in common directory?
isInCommonDirectory = directory.includes('src/components/common/');

// Should component be decomposed?
compositionComplexity.shouldDecompose =
  compositionComplexity.childComponentCount > 10 ||
  compositionComplexity.nestingDepth > 4;

// Principle I compliance (100% coverage, integration-first)
constitutionCompliance["Principle I"] =
  coverage.total.coveragePercentage >= 100;

// Principle II compliance (reusability)
constitutionCompliance["Principle II"] =
  hasSingleResponsibility &&
  hasPropsDocumentation &&
  propsInterface.hasTypeChecking &&
  !compositionComplexity.shouldDecompose;

// Principle VI compliance (accessibility)
constitutionCompliance["Principle VI"] =
  isAccessible &&
  accessibilityViolations.length === 0 &&
  accessibilityFeatures.hasKeyboardNavigation &&
  accessibilityFeatures.meetsContrastRequirements;

// Overall compliance
constitutionCompliance.overallCompliant = Object.values(constitutionCompliance)
  .filter(v => typeof v === 'boolean')
  .every(v => v === true);
```

**Example Component**:
```javascript
{
  name: "MusicalStaff",
  filePath: "/src/components/musical/MusicalStaff.js",
  directory: "src/components/musical/",
  type: "presentational",
  isMusicalFeature: true,
  musicalCapabilities: ["notation", "vexflow-rendering"],

  // Principle II: Reusability
  isReusable: true,
  isInCommonDirectory: false,  // VIOLATION: Should be in common/
  hasSingleResponsibility: true,
  hasPropsDocumentation: true,
  propsInterface: {
    propCount: 8,
    requiredProps: ["notes", "clef", "timeSignature"],
    optionalProps: ["width", "height", "showBarlines", "interactive", "onNoteClick"],
    hasDefaultProps: true,
    hasTypeChecking: true
  },

  // Principle VI: Accessibility
  isAccessible: false,  // VIOLATION: Missing keyboard navigation
  accessibilityViolations: [
    { id: "a11y-001", ruleId: "keyboard", impact: "serious" }
  ],
  accessibilityFeatures: {
    hasKeyboardNavigation: false,  // VIOLATION
    hasAriaLabels: true,
    meetsContrastRequirements: true,
    hasTextAlternatives: false,  // VIOLATION: Canvas needs alt text
    hasSemanticHTML: true
  },

  // Test coverage
  coverage: {
    integration: {
      testCount: 12,
      coveragePercentage: 85,
      testFiles: ["/src/__integration__/musical-staff.test.js"]
    },
    e2e: {
      testCount: 3,
      coveragePercentage: 10,
      testFiles: ["/e2e/notation-rendering.spec.js"]
    },
    unit: {
      testCount: 2,
      coveragePercentage: 5,
      testFiles: ["/src/lib/vexflow-helpers.test.js"]
    },
    total: {
      testCount: 17,
      coveragePercentage: 100
    }
  },

  // Constitutional compliance
  constitutionCompliance: {
    "Principle I": true,   // 100% coverage achieved
    "Principle II": false, // Not in common directory
    "Principle VI": false, // Accessibility violations
    overallCompliant: false,
    violations: [
      "Component should be in src/components/common/ for reusability",
      "Missing keyboard navigation support",
      "Canvas needs text alternatives for screen readers"
    ]
  }
}
```

---

### Entity 6: AccessibilityViolation

**Description**: A specific WCAG 2.1 accessibility issue detected by automated testing tools (jest-axe, @axe-core/playwright, eslint-plugin-jsx-a11y) or manual accessibility audits.

**Fields**:
```typescript
interface AccessibilityViolation {
  // Identification
  id: string;                    // Unique violation ID
  ruleId: string;                // axe-core rule ID (e.g., "color-contrast", "aria-required-attr")

  // Severity and impact
  impact: ImpactLevel;           // "critical" | "serious" | "moderate" | "minor"
  wcagLevel: WCAGLevel;          // "A" | "AA" | "AAA"
  wcagCriteria: string[];        // WCAG success criteria (e.g., ["1.4.3", "1.4.6"])

  // Description and remediation
  description: string;           // Human-readable description
  helpUrl: string;               // Link to axe-core documentation
  fixSuggestion: string;         // Recommended fix
  example: string;               // Code example showing correct usage

  // Affected elements
  affectedComponents: string[]; // Component names with this violation
  affectedNodes: Array<{
    selector: string;            // CSS selector or XPath
    html: string;                // HTML snippet
    target: string[];            // Array of selectors to uniquely identify element
  }>;

  // Detection and tracking
  detectedBy: DetectionMethod;   // "jest-axe" | "@axe-core/playwright" | "eslint-plugin-jsx-a11y" | "manual"
  detectedAt: Date;              // When violation was first detected
  status: ViolationStatus;       // "open" | "fixed" | "false-positive" | "wont-fix"
  resolvedAt: Date | null;       // When violation was resolved
  resolvedBy: string | null;     // Who resolved it
  resolutionNotes: string | null; // How it was resolved or why false-positive

  // Priority and blocking
  blocksCI: boolean;             // Should this fail CI/CD?
  mustFixBeforeMerge: boolean;   // Based on impact and WCAG level
  assignedTo: string | null;     // Developer assigned to fix
  relatedIssue: string | null;   // GitHub issue number
}

type ImpactLevel = "critical" | "serious" | "moderate" | "minor";
type WCAGLevel = "A" | "AA" | "AAA";
type DetectionMethod = "jest-axe" | "@axe-core/playwright" | "eslint-plugin-jsx-a11y" | "manual";
type ViolationStatus = "open" | "fixed" | "false-positive" | "wont-fix";
```

**Relationships**:
- **Belongs to** one or more ComponentUnderTest entities (many-to-many)
- **Belongs to** one AccessibilityAudit (many-to-one)

**Validation Rules** (from FR-012, FR-013, FR-014, SC-007, SC-008):
- `impact === "critical"` violations MUST block CI/CD (`blocksCI = true`)
- `impact === "serious"` violations MUST block CI/CD (`blocksCI = true`)
- All violations with `wcagLevel === "AA"` MUST be fixed before merge
- `status` MUST be "fixed" or justified as "false-positive" with `resolutionNotes`
- "wont-fix" status requires constitutional exception and justification
- `mustFixBeforeMerge` MUST be true for critical/serious violations

**WCAG 2.1 AA Criteria Mapping**:
```javascript
const wcagMapping = {
  // Principle 1: Perceivable
  "color-contrast": ["1.4.3"],           // Contrast (Minimum) - AA
  "image-alt": ["1.1.1"],                // Non-text Content - A
  "audio-caption": ["1.2.2"],            // Captions (Prerecorded) - A
  "label": ["1.3.1"],                    // Info and Relationships - A

  // Principle 2: Operable
  "keyboard": ["2.1.1"],                 // Keyboard - A
  "focus-order": ["2.4.3"],              // Focus Order - A
  "link-name": ["2.4.4"],                // Link Purpose (In Context) - A
  "bypass": ["2.4.1"],                   // Bypass Blocks - A

  // Principle 3: Understandable
  "aria-required-attr": ["4.1.2"],       // Name, Role, Value - A
  "aria-valid-attr": ["4.1.2"],          // Name, Role, Value - A
  "label-content-name-mismatch": ["2.5.3"], // Label in Name - A

  // Principle 4: Robust
  "duplicate-id": ["4.1.1"],             // Parsing - A
  "valid-lang": ["3.1.1"],               // Language of Page - A
};
```

**Blocking Rules**:
```javascript
function calculateBlockingStatus(violation) {
  const blocksCI =
    violation.impact === "critical" ||
    violation.impact === "serious" ||
    (violation.wcagLevel === "AA" && violation.status === "open");

  const mustFixBeforeMerge =
    violation.impact === "critical" ||
    violation.impact === "serious" ||
    violation.wcagLevel === "AA";

  return { blocksCI, mustFixBeforeMerge };
}
```

**Example Violation**:
```javascript
{
  id: "a11y-001",
  ruleId: "color-contrast",
  impact: "serious",
  wcagLevel: "AA",
  wcagCriteria: ["1.4.3"],
  description: "Element has insufficient color contrast of 3.2:1 (foreground color: #888888, background color: #ffffff)",
  helpUrl: "https://dequeuniversity.com/rules/axe/4.7/color-contrast",
  fixSuggestion: "Ensure contrast ratio is at least 4.5:1 for normal text or 3:1 for large text",
  example: "Use #767676 instead of #888888 for 4.5:1 contrast ratio",

  affectedComponents: ["ColorKey"],
  affectedNodes: [
    {
      selector: ".color-key-label",
      html: '<span class="color-key-label">Note label</span>',
      target: [".color-key", ".color-key-label"]
    }
  ],

  detectedBy: "jest-axe",
  detectedAt: new Date("2025-11-13"),
  status: "open",
  resolvedAt: null,
  resolvedBy: null,
  resolutionNotes: null,

  blocksCI: true,              // Serious + AA level
  mustFixBeforeMerge: true,
  assignedTo: "dev-team",
  relatedIssue: "#123"
}
```

---

### Entity 7: AccessibilityAudit

**Description**: A comprehensive accessibility assessment of the application or specific components, aggregating all detected violations, compliance status, and validation results against WCAG 2.1 AA standards.

**Fields**:
```typescript
interface AccessibilityAudit {
  // Identification
  id: string;                    // Unique identifier
  timestamp: Date;               // When audit was performed
  auditVersion: string;          // Semantic version (e.g., "1.0.0")

  // Audit configuration
  auditType: AuditType;          // "automated" | "manual" | "combined"
  scope: AuditScope;             // "full-application" | "component-specific" | "page-specific"
  toolsUsed: string[];           // ["jest-axe", "@axe-core/playwright", "NVDA", "VoiceOver", "WAVE"]
  components Audited: string[];  // List of component names audited
  pagesAudited: string[];        // List of pages/routes audited

  // Violation counts
  totalViolations: number;       // Total count of all violations
  criticalViolations: number;    // Count of critical violations
  seriousViolations: number;     // Count of serious violations
  moderateViolations: number;    // Count of moderate violations
  minorViolations: number;       // Count of minor violations

  // Violation breakdown by type
  violationsByType: Record<string, number>; // ruleId → count
  violationsByComponent: Record<string, number>; // component → count

  // WCAG compliance status
  wcagCompliance: {
    "A": {
      compliant: boolean;
      totalCriteria: number;
      passedCriteria: number;
      failedCriteria: string[];  // e.g., ["1.1.1", "2.1.1"]
    };
    "AA": {
      compliant: boolean;        // MUST be true per constitution
      totalCriteria: number;
      passedCriteria: number;
      failedCriteria: string[];
    };
    "AAA": {
      compliant: boolean;
      totalCriteria: number;
      passedCriteria: number;
      failedCriteria: string[];
    };
  };

  // Constitutional requirements (Principle VI)
  constitutionalCompliance: {
    keyboardNavigationPassed: boolean;     // FR-012
    colorNotSoleChannel: boolean;          // FR-013
    colorContrastPassed: boolean;          // FR-014
    screenReaderCompatible: boolean;       // Manual test
    textAlternativesExist: boolean;        // Manual test
    overallCompliance: boolean;            // All MUST be true
  };

  // Manual testing results (supplement automated tools)
  manualTestResults: {
    keyboardNavigation: {
      tested: boolean;
      passed: boolean;
      notes: string;
      tester: string;
      testDate: Date;
    };
    screenReader: {
      tested: boolean;
      passed: boolean;
      tool: string;              // "NVDA" | "JAWS" | "VoiceOver"
      notes: string;
      tester: string;
      testDate: Date;
    };
    colorBlindnessSimulation: {
      tested: boolean;
      passed: boolean;
      types Tested: string[];     // ["protanopia", "deuteranopia", "tritanopia"]
      notes: string;
    };
  };

  // Status and reporting
  status: AuditStatus;           // "in-progress" | "completed" | "failed" | "passed"
  passesConstitution: boolean;   // Gates CI/CD
  reportUrl: string;             // URL to detailed HTML report
  jsonReportPath: string;        // Path to JSON report file

  // CI/CD integration
  ciJobId: string | null;        // CI job that ran this audit
  gitCommit: string | null;      // Git commit SHA
  gitBranch: string | null;      // Git branch name
}

type AuditType = "automated" | "manual" | "combined";
type AuditScope = "full-application" | "component-specific" | "page-specific";
type AuditStatus = "in-progress" | "completed" | "failed" | "passed";
```

**Relationships**:
- **Has many** AccessibilityViolation entities (one-to-many)
- **References** multiple ComponentUnderTest entities (many-to-many)

**Validation Rules** (from FR-012, FR-013, FR-014, SC-007, SC-008):
- `criticalViolations` MUST be 0
- `seriousViolations` MUST be 0
- `wcagCompliance.AA.compliant` MUST be true (100% AA compliance required)
- `constitutionalCompliance.keyboardNavigationPassed` MUST be true
- `constitutionalCompliance.colorContrastPassed` MUST be true
- `constitutionalCompliance.overallCompliance` MUST be true before feature can be merged
- `passesConstitution` MUST be true for CI/CD to pass

**State Transitions**:
```
in-progress → completed → passed/failed
failed → in-progress (on re-audit after fixes)
passed → in-progress (on regression testing)
```

**Derived Calculations**:
```javascript
// Total violations
totalViolations =
  criticalViolations +
  seriousViolations +
  moderateViolations +
  minorViolations;

// WCAG AA compliance
wcagCompliance.AA.compliant =
  wcagCompliance.AA.failedCriteria.length === 0 &&
  wcagCompliance.AA.passedCriteria === wcagCompliance.AA.totalCriteria;

// Constitutional compliance
constitutionalCompliance.overallCompliance =
  constitutionalCompliance.keyboardNavigationPassed &&
  constitutionalCompliance.colorNotSoleChannel &&
  constitutionalCompliance.colorContrastPassed &&
  constitutionalCompliance.screenReaderCompatible &&
  constitutionalCompliance.textAlternativesExist;

// Passes constitution (gates CI/CD)
passesConstitution =
  criticalViolations === 0 &&
  seriousViolations === 0 &&
  wcagCompliance.AA.compliant &&
  constitutionalCompliance.overallCompliance;

// Audit status
if (passesConstitution && status === "completed") {
  status = "passed";
} else if (status === "completed") {
  status = "failed";
}
```

**Example Audit**:
```javascript
{
  id: "audit-2025-11-13-001",
  timestamp: new Date("2025-11-13T14:30:00Z"),
  auditVersion: "1.0.0",

  auditType: "combined",
  scope: "full-application",
  toolsUsed: ["jest-axe", "@axe-core/playwright", "NVDA", "manual-testing"],
  componentsAudited: ["ColorKey", "TopMenu", "MusicalStaff", "ExercisePlayer"],
  pagesAudited: ["/", "/exercises", "/theory"],

  // Violations
  totalViolations: 8,
  criticalViolations: 0,
  seriousViolations: 2,         // BLOCKS CI
  moderateViolations: 4,
  minorViolations: 2,

  violationsByType: {
    "color-contrast": 3,
    "keyboard": 2,
    "aria-required-attr": 1,
    "label": 2
  },

  violationsByComponent: {
    "ColorKey": 3,
    "MusicalStaff": 2,
    "TopMenu": 3
  },

  // WCAG compliance
  wcagCompliance: {
    "AA": {
      compliant: false,          // FAILS CONSTITUTION
      totalCriteria: 50,
      passedCriteria: 47,
      failedCriteria: ["1.4.3", "2.1.1", "4.1.2"] // color-contrast, keyboard, aria
    }
  },

  // Constitutional compliance
  constitutionalCompliance: {
    keyboardNavigationPassed: false,  // FAILS CONSTITUTION
    colorNotSoleChannel: true,
    colorContrastPassed: false,       // FAILS CONSTITUTION
    screenReaderCompatible: true,
    textAlternativesExist: false,     // FAILS CONSTITUTION
    overallCompliance: false          // FAILS CONSTITUTION
  },

  // Manual testing
  manualTestResults: {
    keyboardNavigation: {
      tested: true,
      passed: false,
      notes: "Unable to navigate to note selection dropdown via keyboard",
      tester: "qa-team",
      testDate: new Date("2025-11-13")
    },
    screenReader: {
      tested: true,
      passed: true,
      tool: "NVDA",
      notes: "All text content accessible, some canvas notation needs improvement",
      tester: "qa-team",
      testDate: new Date("2025-11-13")
    }
  },

  status: "failed",              // FAILS due to violations
  passesConstitution: false,     // BLOCKS CI/CD
  reportUrl: "http://localhost:3000/a11y-reports/audit-2025-11-13-001.html",
  jsonReportPath: "/a11y-reports/audit-2025-11-13-001.json"
}
```

---

### Entity 8: PerformanceMetric

**Description**: Measured performance data for audio latency, notation rendering, UI responsiveness, and test execution time validation. Enforces Constitutional Principle IV (Performance & Responsiveness).

**Fields**:
```typescript
interface PerformanceMetric {
  // Identification
  id: string;                    // Unique identifier
  metricType: MetricType;        // Type of performance measurement
  metricName: string;            // Human-readable name

  // Measurement
  measuredValue: number;         // Measured value (ms, fps, etc.)
  unit: MetricUnit;              // "milliseconds" | "fps" | "seconds" | "hertz"
  threshold: number;             // Constitutional requirement threshold
  isPassing: boolean;            // measuredValue meets threshold
  marginOfError: number;         // Acceptable variance (+/-)

  // Context
  component: string | null;      // Component being measured (if applicable)
  feature: string | null;        // Feature being measured (if applicable)
  testEnvironment: Environment;  // "dev-machine" | "ci-environment" | "target-device"
  browser: Browser;              // "chromium" | "firefox" | "webkit" | "node"
  deviceSpecs: {
    cpu: string;
    ram: string;
    os: string;
    isTargetDevice: boolean;     // Is this a target educational device?
  };

  // Measurement details
  measurements: number[];        // Array of individual measurements
  averageValue: number;          // Average of measurements
  medianValue: number;           // Median of measurements
  minValue: number;              // Best (lowest for latency, highest for fps)
  maxValue: number;              // Worst (highest for latency, lowest for fps)
  standardDeviation: number;     // Variance in measurements

  // Timestamp and tracking
  measuredAt: Date;              // When measurement was taken
  measuredBy: MeasurementTool;   // Tool used for measurement
  testCase: string | null;       // TestCase ID that measured this

  // Constitutional validation
  constitutionalRequirement: string; // Which principle/FR this validates
  meetsConstitution: boolean;    // Does this pass constitutional threshold?
  violationReason: string | null; // Why it failed (if applicable)
}

type MetricType =
  | "audio-latency"
  | "notation-rendering"
  | "frame-rate"
  | "test-execution-time"
  | "audio-visual-sync"
  | "user-interaction-response";

type MetricUnit = "milliseconds" | "fps" | "seconds" | "hertz";

type Environment = "dev-machine" | "ci-environment" | "target-device";

type Browser = "chromium" | "firefox" | "webkit" | "node";

type MeasurementTool =
  | "Playwright Performance API"
  | "Tone.js AudioContext"
  | "browser.Performance API"
  | "Jest Performance"
  | "Chrome DevTools Performance"
  | "Lighthouse";
```

**Relationships**:
- **May reference** ComponentUnderTest (many-to-one, optional)
- **May reference** TestCase that measured it (many-to-one, optional)
- **Belongs to** PerformanceSuite (many-to-one, conceptual grouping)

**Validation Rules** (from FR-015, FR-016, FR-017, SC-005, SC-006):

**Audio Latency** (FR-015, SC-005):
- `measuredValue` MUST be < 50ms for interactive instruments
- `testEnvironment` MUST include "target-device" measurements
- `isPassing` MUST be true for CI/CD to pass

**Notation Rendering** (FR-016, SC-006):
- `measuredValue` MUST be < 200ms for typical exercises
- Measurements MUST be taken for representative exercises (not trivial cases)
- `isPassing` MUST be true for CI/CD to pass

**Frame Rate**:
- `measuredValue` MUST be >= 60fps for UI animations (where applicable)
- Measured during actual user interactions, not idle state

**Test Execution Time** (FR-003, FR-004, SC-003, SC-004):
- Integration tests: `measuredValue` MUST be < 5000ms per test
- E2E tests: `measuredValue` MUST be < 30000ms per test

**Target Device Requirement** (FR-017):
- At least one measurement MUST have `deviceSpecs.isTargetDevice === true`
- Target device specs: Minimum 2GB RAM, dual-core processor, modern browser

**Threshold Mapping**:
```javascript
const constitutionalThresholds = {
  "audio-latency": { threshold: 50, unit: "milliseconds", comparison: "<" },
  "notation-rendering": { threshold: 200, unit: "milliseconds", comparison: "<" },
  "frame-rate": { threshold: 60, unit: "fps", comparison: ">=" },
  "test-execution-time": {
    integration: { threshold: 5000, unit: "milliseconds", comparison: "<" },
    e2e: { threshold: 30000, unit: "milliseconds", comparison: "<" }
  },
  "audio-visual-sync": { threshold: 10, unit: "milliseconds", comparison: "<" }
};
```

**Derived Calculations**:
```javascript
// Statistical calculations
averageValue = measurements.reduce((a, b) => a + b) / measurements.length;
medianValue = measurements.sort()[Math.floor(measurements.length / 2)];
minValue = Math.min(...measurements);
maxValue = Math.max(...measurements);

// Standard deviation
const mean = averageValue;
const squaredDiffs = measurements.map(v => Math.pow(v - mean, 2));
standardDeviation = Math.sqrt(squaredDiffs.reduce((a, b) => a + b) / measurements.length);

// Pass/fail determination (for latency/rendering - lower is better)
if (metricType === "audio-latency" || metricType === "notation-rendering" || metricType === "test-execution-time") {
  isPassing = measuredValue < threshold;
  meetsConstitution = averageValue < threshold && maxValue < (threshold * 1.2); // Allow 20% spike
}

// Pass/fail for frame rate (higher is better)
if (metricType === "frame-rate") {
  isPassing = measuredValue >= threshold;
  meetsConstitution = averageValue >= threshold && minValue >= (threshold * 0.9); // Allow 10% dip
}
```

**Example Metrics**:

**Audio Latency Measurement**:
```javascript
{
  id: "perf-001",
  metricType: "audio-latency",
  metricName: "Interactive Piano Audio Latency",

  measuredValue: 38,             // 38ms average latency
  unit: "milliseconds",
  threshold: 50,
  isPassing: true,               // PASSES (38 < 50)
  marginOfError: 5,

  component: "PianoKeyboard",
  feature: "Interactive instrument playback",
  testEnvironment: "target-device",
  browser: "chromium",
  deviceSpecs: {
    cpu: "Intel Core i3-8130U",
    ram: "4GB",
    os: "Windows 11",
    isTargetDevice: true         // Validated on actual target device
  },

  measurements: [35, 38, 42, 36, 39, 38, 40], // Multiple measurements
  averageValue: 38.3,
  medianValue: 38,
  minValue: 35,
  maxValue: 42,
  standardDeviation: 2.1,

  measuredAt: new Date("2025-11-13"),
  measuredBy: "Tone.js AudioContext",
  testCase: "e2e-002-piano-latency",

  constitutionalRequirement: "Principle IV (FR-015, SC-005): Audio latency < 50ms",
  meetsConstitution: true,
  violationReason: null
}
```

**Notation Rendering Measurement**:
```javascript
{
  id: "perf-002",
  metricType: "notation-rendering",
  metricName: "VexFlow Staff Rendering Performance",

  measuredValue: 145,            // 145ms average
  unit: "milliseconds",
  threshold: 200,
  isPassing: true,               // PASSES (145 < 200)
  marginOfError: 20,

  component: "MusicalStaff",
  feature: "Musical notation rendering",
  testEnvironment: "ci-environment",
  browser: "chromium",
  deviceSpecs: {
    cpu: "GitHub Actions Runner",
    ram: "7GB",
    os: "Ubuntu 22.04",
    isTargetDevice: false
  },

  measurements: [120, 145, 160, 135, 150, 140, 155],
  averageValue: 143.6,
  medianValue: 145,
  minValue: 120,
  maxValue: 160,
  standardDeviation: 13.5,

  measuredAt: new Date("2025-11-13"),
  measuredBy: "browser.Performance API",
  testCase: "int-003-notation-render",

  constitutionalRequirement: "Principle IV (FR-016, SC-006): Notation rendering < 200ms",
  meetsConstitution: true,
  violationReason: null
}
```

**Test Execution Time (Integration)**:
```javascript
{
  id: "perf-003",
  metricType: "test-execution-time",
  metricName: "Integration Test Suite Execution Time",

  measuredValue: 4200,           // 4.2s average per test
  unit: "milliseconds",
  threshold: 5000,
  isPassing: true,               // PASSES (4200 < 5000)

  testEnvironment: "ci-environment",
  browser: "node",

  measurements: [3800, 4200, 4500, 4100, 4300],
  averageValue: 4180,
  medianValue: 4200,

  measuredAt: new Date("2025-11-13"),
  measuredBy: "Jest Performance",

  constitutionalRequirement: "Principle I (FR-003, SC-003): Integration tests < 5s",
  meetsConstitution: true,
  violationReason: null
}
```

**Failed Performance Metric Example**:
```javascript
{
  id: "perf-004",
  metricType: "audio-latency",
  metricName: "Audio Latency on Low-End Device",

  measuredValue: 68,             // 68ms - FAILS
  unit: "milliseconds",
  threshold: 50,
  isPassing: false,              // FAILS (68 > 50)

  component: "AudioPlayer",
  testEnvironment: "target-device",
  browser: "webkit",
  deviceSpecs: {
    cpu: "ARM Cortex-A53",
    ram: "2GB",
    os: "iOS 15",
    isTargetDevice: true
  },

  measurements: [65, 68, 72, 66, 70],
  averageValue: 68.2,
  maxValue: 72,

  measuredAt: new Date("2025-11-13"),
  measuredBy: "Tone.js AudioContext",

  constitutionalRequirement: "Principle IV (FR-015): Audio latency < 50ms",
  meetsConstitution: false,      // BLOCKS CI/CD
  violationReason: "Audio latency of 68ms exceeds 50ms threshold on target iOS device. Consider optimizing audio buffer size or using lower-latency audio context settings."
}
```

---

### Entity 9: TestConfiguration

**Description**: Configuration settings for test infrastructure, including Jest config, Playwright config, coverage thresholds, test organization, and constitutional compliance enforcement rules.

**Fields**:
```typescript
interface TestConfiguration {
  // Identification
  id: string;                    // Unique identifier
  version: string;               // Config version (semantic versioning)
  environment: string;           // "development" | "ci" | "production"

  // Jest Configuration
  jestConfig: {
    testEnvironment: string;     // "jsdom" | "node"
    setupFilesAfterEnv: string[]; // Setup files
    testMatch: string[];         // Test file patterns
    collectCoverageFrom: string[]; // Files to include in coverage
    coveragePathIgnorePatterns: string[]; // Files to exclude from coverage
    transformIgnorePatterns: string[]; // Transform ignore patterns
    moduleNameMapper: Record<string, string>; // Module path aliases
    globals: Record<string, any>; // Global variables
    testTimeout: number;         // Default test timeout (ms)
  };

  // Playwright Configuration
  playwrightConfig: {
    testDir: string;             // E2E test directory
    timeout: number;             // Test timeout (30000ms)
    retries: number;             // Retry count for flaky tests
    workers: number;             // Parallel workers
    projects: Array<{
      name: string;              // "chromium" | "firefox" | "webkit"
      use: Record<string, any>;  // Browser-specific settings
    }>;
    webServer: {
      command: string;           // "npm start"
      port: number;              // 3000
      reuseExistingServer: boolean;
    };
    use: {
      baseURL: string;
      trace: string;             // "on-first-retry" | "on" | "off"
      screenshot: string;        // "only-on-failure" | "on" | "off"
      video: string;             // "retain-on-failure" | "on" | "off"
      launchOptions: {
        args: string[];          // Browser launch arguments
        ignoreDefaultArgs: string[]; // Default args to ignore
      };
    };
  };

  // Coverage Thresholds (Constitutional Requirements)
  coverageThresholds: {
    global: {
      branches: number;          // Required: 100
      functions: number;         // Required: 100
      lines: number;             // Required: 100
      statements: number;        // Required: 100
    };
    perFile: {
      branches: number;          // Required: 100 per file
      functions: number;         // Required: 100 per file
      lines: number;             // Required: 100 per file
      statements: number;        // Required: 100 per file
    };
  };

  // Test Organization
  testDirectories: {
    integration: string;         // "__integration__" or "tests/integration"
    e2e: string;                 // "e2e" or "tests/e2e"
    unit: string;                // "__test__" or "tests/unit"
    accessibility: string;       // "__a11y__" or "tests/a11y"
  };

  testPatterns: {
    integration: string[];       // ["**/__integration__/**/*.test.js"]
    e2e: string[];               // ["**/e2e/**/*.spec.js"]
    unit: string[];              // ["**/__test__/**/*.test.js"]
    accessibility: string[];     // ["**/__a11y__/**/*.test.js"]
  };

  // Constitutional Enforcement
  constitutionEnforcement: {
    enforce100Coverage: boolean;           // true (NON-NEGOTIABLE)
    enforceIntegrationPercentage: boolean; // true (60-70%)
    enforceE2EPercentage: boolean;         // true (20-30%)
    enforceUnitPercentage: boolean;        // true (10-20%)
    failOnAccessibilityViolations: boolean; // true (critical/serious)
    failOnPerformanceViolations: boolean;  // true (latency/rendering thresholds)
    failOnUntestedComponents: boolean;     // true (all components must have tests)

    integrationTestRange: [number, number]; // [60, 70]
    e2eTestRange: [number, number];         // [20, 30]
    unitTestRange: [number, number];        // [10, 20]

    performanceThresholds: {
      audioLatency: number;      // 50ms
      notationRendering: number; // 200ms
      integrationTestTime: number; // 5000ms
      e2eTestTime: number;       // 30000ms
    };

    accessibilityThresholds: {
      wcagLevel: "A" | "AA" | "AAA"; // "AA" required
      blockOnCritical: boolean;      // true
      blockOnSerious: boolean;       // true
      blockOnModerate: boolean;      // false
    };
  };

  // CI/CD Integration
  ciConfig: {
    runOnPush: boolean;
    runOnPullRequest: boolean;
    requirePassingTests: boolean;
    requireCoverageThresholds: boolean;
    requireAccessibilityPass: boolean;
    requirePerformancePass: boolean;
    uploadArtifacts: boolean;
    artifactPaths: string[];     // Coverage reports, test results, a11y reports
  };

  // Reporting
  reporters: {
    jest: string[];              // ["default", "jest-html-reporter"]
    playwright: string[];        // ["html", "json", "junit"]
    coverage: string[];          // ["html", "text", "lcov", "clover"]
  };

  reportPaths: {
    jestResults: string;         // "test-results/jest-results.json"
    playwrightResults: string;   // "playwright-report/"
    coverage: string;            // "coverage/"
    accessibility: string;       // "a11y-reports/"
    performance: string;         // "performance/"
  };
}
```

**Relationships**:
- **Configures** all TestSuite entities (one-to-many)
- **Defines thresholds for** CoverageReport validation
- **Defines thresholds for** PerformanceMetric validation
- **Defines thresholds for** AccessibilityAudit validation

**Validation Rules** (from FR-001, FR-002, FR-003, FR-004, FR-018):
- `coverageThresholds.global.lines` MUST be 100
- `coverageThresholds.global.branches` MUST be 100
- `constitutionEnforcement.enforce100Coverage` MUST be true (NON-NEGOTIABLE)
- `constitutionEnforcement.integrationTestRange` MUST be [60, 70]
- `constitutionEnforcement.e2eTestRange` MUST be [20, 30]
- `constitutionEnforcement.unitTestRange` MUST be [10, 20]
- `playwrightConfig.timeout` MUST be <= 30000ms (30 seconds)
- Test directories MUST exist before running tests

**Default Configuration** (as per Notio's requirements):
```javascript
const defaultTestConfiguration = {
  id: "config-v1",
  version: "1.0.0",
  environment: "development",

  jestConfig: {
    testEnvironment: "jsdom",
    setupFilesAfterEnv: ["<rootDir>/src/setupTests.js"],
    testMatch: [
      "**/__test__/**/*.test.js",
      "**/__integration__/**/*.test.js"
    ],
    collectCoverageFrom: [
      "src/**/*.{js,jsx}",
      "!src/index.js",
      "!src/__test__/**",
      "!src/__integration__/**",
      "!src/__mocks__/**"
    ],
    coveragePathIgnorePatterns: [
      "/node_modules/",
      "/__test__/",
      "/__mocks__/"
    ],
    transformIgnorePatterns: [
      "node_modules/(?!(vexflow|@tonejs/piano|gsap)/)"
    ],
    testTimeout: 10000
  },

  playwrightConfig: {
    testDir: "./e2e",
    timeout: 30000,              // Constitutional requirement
    retries: 1,
    workers: 4,
    projects: [
      { name: "chromium", use: {} },
      { name: "firefox", use: {} },
      { name: "webkit", use: {} }
    ],
    webServer: {
      command: "npm start",
      port: 3000,
      reuseExistingServer: true
    },
    use: {
      baseURL: "http://localhost:3000",
      trace: "on-first-retry",
      screenshot: "only-on-failure",
      video: "retain-on-failure",
      launchOptions: {
        args: [
          "--autoplay-policy=no-user-gesture-required",
          "--use-fake-device-for-media-stream"
        ],
        ignoreDefaultArgs: ["--mute-audio"]
      }
    }
  },

  coverageThresholds: {
    global: {
      branches: 100,             // Constitutional requirement
      functions: 100,
      lines: 100,
      statements: 100
    },
    perFile: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  },

  testDirectories: {
    integration: "src/__integration__",
    e2e: "e2e",
    unit: "src/__test__",
    accessibility: "src/__a11y__"
  },

  testPatterns: {
    integration: ["**/__integration__/**/*.test.js"],
    e2e: ["**/e2e/**/*.spec.js"],
    unit: ["**/__test__/**/*.test.js"],
    accessibility: ["**/__a11y__/**/*.test.js"]
  },

  constitutionEnforcement: {
    enforce100Coverage: true,              // NON-NEGOTIABLE
    enforceIntegrationPercentage: true,
    enforceE2EPercentage: true,
    enforceUnitPercentage: true,
    failOnAccessibilityViolations: true,
    failOnPerformanceViolations: true,
    failOnUntestedComponents: true,

    integrationTestRange: [60, 70],
    e2eTestRange: [20, 30],
    unitTestRange: [10, 20],

    performanceThresholds: {
      audioLatency: 50,
      notationRendering: 200,
      integrationTestTime: 5000,
      e2eTestTime: 30000
    },

    accessibilityThresholds: {
      wcagLevel: "AA",
      blockOnCritical: true,
      blockOnSerious: true,
      blockOnModerate: false
    }
  },

  ciConfig: {
    runOnPush: true,
    runOnPullRequest: true,
    requirePassingTests: true,
    requireCoverageThresholds: true,
    requireAccessibilityPass: true,
    requirePerformancePass: true,
    uploadArtifacts: true,
    artifactPaths: [
      "coverage/",
      "playwright-report/",
      "a11y-reports/",
      "performance/"
    ]
  },

  reporters: {
    jest: ["default", "jest-html-reporter"],
    playwright: ["html", "json", "junit"],
    coverage: ["html", "text", "lcov", "clover"]
  },

  reportPaths: {
    jestResults: "test-results/jest-results.json",
    playwrightResults: "playwright-report/",
    coverage: "coverage/",
    accessibility: "a11y-reports/",
    performance: "performance/"
  }
};
```

**CI/CD Validation Logic**:
```javascript
function validateConstitutionalCompliance(
  coverageReport: CoverageReport,
  accessibilityAudit: AccessibilityAudit,
  performanceMetrics: PerformanceMetric[],
  config: TestConfiguration
): { passed: boolean; violations: string[] } {
  const violations = [];

  // Check 100% coverage requirement
  if (config.constitutionEnforcement.enforce100Coverage) {
    if (coverageReport.lineCoverage < 100) {
      violations.push(`Line coverage is ${coverageReport.lineCoverage}% (requires 100%)`);
    }
    if (coverageReport.branchCoverage < 100) {
      violations.push(`Branch coverage is ${coverageReport.branchCoverage}% (requires 100%)`);
    }
  }

  // Check test distribution
  const dist = coverageReport.testDistribution;
  const [intMin, intMax] = config.constitutionEnforcement.integrationTestRange;
  const [e2eMin, e2eMax] = config.constitutionEnforcement.e2eTestRange;
  const [unitMin, unitMax] = config.constitutionEnforcement.unitTestRange;

  if (dist.integration.percentage < intMin || dist.integration.percentage > intMax) {
    violations.push(
      `Integration tests are ${dist.integration.percentage}% (requires ${intMin}-${intMax}%)`
    );
  }

  if (dist.e2e.percentage < e2eMin || dist.e2e.percentage > e2eMax) {
    violations.push(
      `E2E tests are ${dist.e2e.percentage}% (requires ${e2eMin}-${e2eMax}%)`
    );
  }

  if (dist.unit.percentage < unitMin || dist.unit.percentage > unitMax) {
    violations.push(
      `Unit tests are ${dist.unit.percentage}% (requires ${unitMin}-${unitMax}%)`
    );
  }

  // Check accessibility
  if (config.constitutionEnforcement.failOnAccessibilityViolations) {
    if (!accessibilityAudit.passesConstitution) {
      violations.push(
        `Accessibility audit failed: ${accessibilityAudit.criticalViolations} critical, ${accessibilityAudit.seriousViolations} serious violations`
      );
    }
  }

  // Check performance
  if (config.constitutionEnforcement.failOnPerformanceViolations) {
    const failing = performanceMetrics.filter(m => !m.meetsConstitution);
    if (failing.length > 0) {
      violations.push(
        `Performance violations: ${failing.map(m => m.violationReason).join("; ")}`
      );
    }
  }

  return {
    passed: violations.length === 0,
    violations
  };
}
```

---

## Entity Relationships

### Relationship Diagram

```
TestConfiguration
  │
  ├──configures──> TestSuite (1:many)
  │                  │
  │                  ├──has──> TestCase (1:many)
  │                  │           │
  │                  │           └──references──> ComponentUnderTest (many:many)
  │                  │
  │                  └──has──> CoverageReport (1:1)
  │                              │
  │                              └──has──> FileCoverageDetail (1:many)
  │                                          │
  │                                          └──references──> ComponentUnderTest (1:1)
  │
  └──defines thresholds for──> AccessibilityAudit (1:many)
                                  │
                                  ├──has──> AccessibilityViolation (1:many)
                                  │           │
                                  │           └──affects──> ComponentUnderTest (many:many)
                                  │
                                  └──validates──> ComponentUnderTest (many:many)

ComponentUnderTest
  │
  ├──tested by──> TestCase (many:many)
  ├──measured by──> PerformanceMetric (1:many)
  ├──has violations──> AccessibilityViolation (1:many)
  └──has coverage──> FileCoverageDetail (1:1)
```

### Relationship Descriptions

**TestConfiguration → TestSuite** (1:many):
- One configuration defines settings for multiple test suites
- Configuration determines which tests are integration/E2E/unit based on file location
- Enforces coverage thresholds and test distribution requirements

**TestSuite → TestCase** (1:many):
- Each test suite contains multiple individual test cases
- Test cases inherit suite type (integration/E2E/unit)
- Suite execution time is sum of all test case execution times

**TestCase → ComponentUnderTest** (many:many):
- A single test case may test multiple components (integration tests)
- A single component may be tested by multiple test cases
- Relationship tracked via `TestCase.affectedComponents` array

**TestSuite → CoverageReport** (1:1 or many:1):
- Each test suite generates coverage data
- Coverage reports can be aggregated across suites
- Global coverage report combines all suites

**CoverageReport → FileCoverageDetail** (1:many):
- Coverage report contains detailed coverage for each source file
- File-level coverage rolls up to overall coverage percentages

**FileCoverageDetail → ComponentUnderTest** (1:1):
- Each component file has corresponding coverage details
- Component entity references coverage detail for test coverage percentage

**AccessibilityAudit → AccessibilityViolation** (1:many):
- Single audit detects multiple violations
- Violations grouped by component and severity

**AccessibilityViolation → ComponentUnderTest** (many:many):
- Single violation may affect multiple components
- Single component may have multiple violations
- Relationship tracked via `AccessibilityViolation.affectedComponents`

**ComponentUnderTest → PerformanceMetric** (1:many):
- Performance-critical components have multiple metrics measured
- Metrics track audio latency, rendering time, etc.

**TestCase → PerformanceMetric** (1:1 or 1:many):
- E2E/integration tests measure performance during execution
- Performance metric references test case that measured it

---

## Validation Rules

### Cross-Entity Validation Rules

These validation rules span multiple entities and enforce constitutional compliance:

#### 1. 100% Coverage with Integration-First Distribution (FR-001, FR-002, SC-001, SC-002)

```javascript
function validate100CoverageWithDistribution(
  coverageReport: CoverageReport,
  testSuites: TestSuite[]
): ValidationResult {
  const errors = [];

  // Validate 100% coverage
  if (coverageReport.lineCoverage < 100) {
    errors.push(`Line coverage is ${coverageReport.lineCoverage}% (requires 100%)`);
  }

  if (coverageReport.branchCoverage < 100) {
    errors.push(`Branch coverage is ${coverageReport.branchCoverage}% (requires 100%)`);
  }

  // Validate test distribution
  const totalTests = testSuites.reduce((sum, suite) => sum + suite.totalTests, 0);
  const integrationTests = testSuites
    .filter(s => s.type === "integration")
    .reduce((sum, suite) => sum + suite.totalTests, 0);
  const e2eTests = testSuites
    .filter(s => s.type === "e2e")
    .reduce((sum, suite) => sum + suite.totalTests, 0);
  const unitTests = testSuites
    .filter(s => s.type === "unit")
    .reduce((sum, suite) => sum + suite.totalTests, 0);

  const integrationPct = (integrationTests / totalTests) * 100;
  const e2ePct = (e2eTests / totalTests) * 100;
  const unitPct = (unitTests / totalTests) * 100;

  if (integrationPct < 60 || integrationPct > 70) {
    errors.push(`Integration tests are ${integrationPct.toFixed(1)}% (requires 60-70%)`);
  }

  if (e2ePct < 20 || e2ePct > 30) {
    errors.push(`E2E tests are ${e2ePct.toFixed(1)}% (requires 20-30%)`);
  }

  if (unitPct < 10 || unitPct > 20) {
    errors.push(`Unit tests are ${unitPct.toFixed(1)}% (requires 10-20%)`);
  }

  return { valid: errors.length === 0, errors };
}
```

#### 2. Component Reusability Compliance (FR-010, FR-011, SC-009)

```javascript
function validateComponentReusability(component: ComponentUnderTest): ValidationResult {
  const errors = [];

  // Check if reusable component is in common directory
  if (component.isReusable && !component.isInCommonDirectory) {
    errors.push(`Component "${component.name}" is reusable but not in src/components/common/`);
  }

  // Check single responsibility
  if (!component.hasSingleResponsibility) {
    errors.push(`Component "${component.name}" violates Single Responsibility Principle`);
  }

  // Check props documentation
  if (!component.hasPropsDocumentation) {
    errors.push(`Component "${component.name}" lacks props documentation`);
  }

  // Check type checking
  if (!component.propsInterface.hasTypeChecking) {
    errors.push(`Component "${component.name}" lacks TypeScript or PropTypes type checking`);
  }

  // Check composition complexity
  if (component.compositionComplexity.shouldDecompose) {
    errors.push(
      `Component "${component.name}" is too complex (${component.compositionComplexity.childComponentCount} children, ` +
      `${component.compositionComplexity.nestingDepth} nesting depth) and should be decomposed`
    );
  }

  return { valid: errors.length === 0, errors };
}
```

#### 3. Accessibility Compliance (FR-012, FR-013, FR-014, SC-007, SC-008)

```javascript
function validateAccessibilityCompliance(
  component: ComponentUnderTest,
  audit: AccessibilityAudit
): ValidationResult {
  const errors = [];

  // Check keyboard navigation
  if (!component.accessibilityFeatures.hasKeyboardNavigation) {
    errors.push(`Component "${component.name}" lacks keyboard navigation support`);
  }

  // Check contrast requirements
  if (!component.accessibilityFeatures.meetsContrastRequirements) {
    errors.push(`Component "${component.name}" fails WCAG 2.1 AA contrast requirements`);
  }

  // Check for critical/serious violations
  const componentViolations = component.accessibilityViolations.filter(
    v => v.impact === "critical" || v.impact === "serious"
  );

  if (componentViolations.length > 0) {
    errors.push(
      `Component "${component.name}" has ${componentViolations.length} critical/serious accessibility violations`
    );
  }

  // Check WCAG 2.1 AA compliance
  if (!audit.wcagCompliance.AA.compliant) {
    errors.push(
      `Accessibility audit failed WCAG 2.1 AA compliance (failed criteria: ${audit.wcagCompliance.AA.failedCriteria.join(", ")})`
    );
  }

  return { valid: errors.length === 0, errors };
}
```

#### 4. Performance Requirements (FR-015, FR-016, FR-017, SC-005, SC-006)

```javascript
function validatePerformanceRequirements(
  metrics: PerformanceMetric[],
  config: TestConfiguration
): ValidationResult {
  const errors = [];

  // Check audio latency
  const audioLatencyMetrics = metrics.filter(m => m.metricType === "audio-latency");
  const failingAudioLatency = audioLatencyMetrics.filter(m => !m.meetsConstitution);

  if (failingAudioLatency.length > 0) {
    errors.push(
      `Audio latency violations: ${failingAudioLatency.map(m =>
        `${m.component}: ${m.measuredValue}ms (requires < ${m.threshold}ms)`
      ).join("; ")}`
    );
  }

  // Check notation rendering
  const renderingMetrics = metrics.filter(m => m.metricType === "notation-rendering");
  const failingRendering = renderingMetrics.filter(m => !m.meetsConstitution);

  if (failingRendering.length > 0) {
    errors.push(
      `Notation rendering violations: ${failingRendering.map(m =>
        `${m.component}: ${m.measuredValue}ms (requires < ${m.threshold}ms)`
      ).join("; ")}`
    );
  }

  // Check target device validation (FR-017)
  const hasTargetDeviceMetrics = metrics.some(m => m.deviceSpecs.isTargetDevice);
  if (!hasTargetDeviceMetrics) {
    errors.push("Performance metrics must include measurements on target educational devices");
  }

  return { valid: errors.length === 0, errors };
}
```

#### 5. Test Execution Time Compliance (FR-003, FR-004, SC-003, SC-004)

```javascript
function validateTestExecutionTime(testSuites: TestSuite[]): ValidationResult {
  const errors = [];

  // Check integration test execution time
  const integrationSuites = testSuites.filter(s => s.type === "integration");
  const slowIntegrationTests = integrationSuites.filter(s => s.averageTestTime >= 5000);

  if (slowIntegrationTests.length > 0) {
    errors.push(
      `Slow integration tests: ${slowIntegrationTests.map(s =>
        `${s.name}: ${s.averageTestTime}ms (requires < 5000ms)`
      ).join("; ")}`
    );
  }

  // Check E2E test execution time
  const e2eSuites = testSuites.filter(s => s.type === "e2e");
  const slowE2ETests = e2eSuites.filter(s => s.averageTestTime >= 30000);

  if (slowE2ETests.length > 0) {
    errors.push(
      `Slow E2E tests: ${slowE2ETests.map(s =>
        `${s.name}: ${s.averageTestTime}ms (requires < 30000ms)`
      ).join("; ")}`
    );
  }

  return { valid: errors.length === 0, errors };
}
```

#### 6. Overall Constitutional Compliance Gate

```javascript
function validateOverallConstitutionalCompliance(
  coverageReport: CoverageReport,
  testSuites: TestSuite[],
  components: ComponentUnderTest[],
  accessibilityAudit: AccessibilityAudit,
  performanceMetrics: PerformanceMetric[],
  config: TestConfiguration
): { passed: boolean; violations: string[]; blockers: string[] } {
  const violations = [];
  const blockers = [];

  // Validate 100% coverage (BLOCKER)
  const coverageValidation = validate100CoverageWithDistribution(coverageReport, testSuites);
  if (!coverageValidation.valid) {
    blockers.push(...coverageValidation.errors);
  }

  // Validate component reusability (WARNING)
  components.forEach(component => {
    const reusabilityValidation = validateComponentReusability(component);
    if (!reusabilityValidation.valid) {
      violations.push(...reusabilityValidation.errors);
    }
  });

  // Validate accessibility (BLOCKER)
  const a11yValidation = validateAccessibilityCompliance(components[0], accessibilityAudit);
  if (!a11yValidation.valid) {
    blockers.push(...a11yValidation.errors);
  }

  // Validate performance (BLOCKER)
  const perfValidation = validatePerformanceRequirements(performanceMetrics, config);
  if (!perfValidation.valid) {
    blockers.push(...perfValidation.errors);
  }

  // Validate test execution time (BLOCKER)
  const timeValidation = validateTestExecutionTime(testSuites);
  if (!timeValidation.valid) {
    blockers.push(...timeValidation.errors);
  }

  return {
    passed: blockers.length === 0,
    violations,  // Non-blocking but should be fixed
    blockers     // Blocks CI/CD pipeline
  };
}
```

---

## State Transitions

### TestSuite State Machine

```
┌─────────┐
│ not-run │
└────┬────┘
     │ start test execution
     ▼
┌─────────┐
│ running │
└────┬────┘
     │ all tests complete
     ▼
┌─────────┐     ┌─────────┐     ┌─────────┐
│ passing │ OR  │ failing │ OR  │ skipped │
└────┬────┘     └────┬────┘     └────┬────┘
     │               │               │
     └───────────────┴───────────────┘
                     │ re-execute
                     ▼
                ┌─────────┐
                │ running │
                └─────────┘
```

**Transition Rules**:
- `not-run → running`: Test execution begins
- `running → passing`: All tests pass (`passedTests === totalTests`)
- `running → failing`: Any test fails (`failedTests > 0`)
- `running → skipped`: All tests skipped
- `passing/failing/skipped → running`: Re-execution triggered

### TestCase State Machine

```
┌─────────┐
│ pending │
└────┬────┘
     │ test execution starts
     ▼
┌─────────┐
│ running │
└────┬────┘
     │ test completes
     ▼
┌────────┐     ┌────────┐     ┌─────────┐
│ passed │ OR  │ failed │ OR  │ skipped │
└───┬────┘     └───┬────┘     └────┬────┘
    │              │               │
    │              │ retry (if retryCount < maxRetries)
    │              ▼               │
    │         ┌─────────┐          │
    │         │ running │          │
    │         └────┬────┘          │
    │              │               │
    └──────────────┴───────────────┘
                   │ re-execute
                   ▼
              ┌─────────┐
              │ running │
              └─────────┘
```

**Transition Rules**:
- `pending → running`: Test begins execution
- `running → passed`: All assertions pass
- `running → failed`: Any assertion fails or error thrown
- `running → skipped`: Test marked as `.skip()` or `.todo()`
- `failed → running`: Retry triggered (max 2 retries for flaky tests)
- `passed/failed/skipped → running`: Re-execution in watch mode or CI

### AccessibilityViolation State Machine

```
┌──────┐
│ open │
└──┬───┘
   │ fix applied
   ▼
┌───────┐
│ fixed │
└───────┘

┌──────┐
│ open │
└──┬───┘
   │ investigated and determined incorrect
   ▼
┌────────────────┐
│ false-positive │
└────────────────┘

┌──────┐
│ open │
└──┬───┘
   │ constitutional exception granted
   ▼
┌──────────┐
│ wont-fix │
└──────────┘
```

**Transition Rules**:
- `open → fixed`: Violation remediated and verified by re-running audit
- `open → false-positive`: Investigation shows violation is false alarm (requires justification in `resolutionNotes`)
- `open → wont-fix`: Constitutional exception granted (requires complexity tracking documentation)

**Status Validation**:
- `false-positive`: Requires `resolutionNotes` explaining why it's a false positive
- `wont-fix`: Requires constitutional exception and `resolutionNotes` with justification
- `fixed`: Requires re-running accessibility audit to verify fix

### AccessibilityAudit State Machine

```
┌─────────────┐
│ in-progress │
└──────┬──────┘
       │ audit completes
       ▼
┌───────────┐
│ completed │
└─────┬─────┘
      │ analyze results
      ▼
┌────────┐     ┌────────┐
│ passed │ OR  │ failed │
└───┬────┘     └───┬────┘
    │              │ fixes applied
    │              ▼
    │         ┌─────────────┐
    │         │ in-progress │
    │         └──────┬──────┘
    │                │ re-audit
    └────────────────┘
```

**Transition Rules**:
- `in-progress → completed`: Audit finishes (automated + manual tests complete)
- `completed → passed`: `passesConstitution === true` (no blockers)
- `completed → failed`: `passesConstitution === false` (critical/serious violations exist)
- `failed → in-progress`: Fixes applied, trigger re-audit
- `passed → in-progress`: Regression testing after code changes

---

## Implementation Notes

### How Entities Map to Test Infrastructure Files

This section describes how the logical entities in this data model map to actual files, tools, and test execution artifacts in the Notio project.

#### 1. TestSuite & TestCase

**Generated By**: Jest (for integration/unit) and Playwright (for E2E)

**File Mapping**:
```
TestSuite.type = "integration"
  → Files in: src/__integration__/**/*.test.js
  → Naming: [feature]-integration.test.js

TestSuite.type = "e2e"
  → Files in: e2e/**/*.spec.js
  → Naming: [workflow].spec.js

TestSuite.type = "unit"
  → Files in: src/__test__/**/*.test.js
  → Naming: [module].test.js

TestCase
  → Individual test() or it() blocks within test files
  → Each describe() block can represent a TestSuite
```

**Example Mapping**:
```javascript
// File: src/__integration__/musical-staff.test.js
describe('MusicalStaff Integration Tests', () => {  // TestSuite
  test('should synchronize audio with notation', () => {  // TestCase
    // Test implementation
  });

  test('should handle user click on note', () => {  // TestCase
    // Test implementation
  });
});
```

#### 2. CoverageReport & FileCoverageDetail

**Generated By**: Istanbul/nyc (via Jest)

**File Mapping**:
```
CoverageReport
  → Generated at: coverage/coverage-final.json
  → HTML report: coverage/lcov-report/index.html
  → LCOV format: coverage/lcov.info
  → Clover XML: coverage/clover.xml

FileCoverageDetail
  → Each file entry in coverage/coverage-final.json
  → Structure:
    {
      "/absolute/path/to/file.js": {
        "path": "...",
        "s": { ... },  // statements
        "b": { ... },  // branches
        "f": { ... },  // functions
        "statementMap": { ... },
        "branchMap": { ... },
        "fnMap": { ... }
      }
    }
```

**Reading Coverage Data**:
```javascript
const coverageData = require('./coverage/coverage-final.json');

// Convert to CoverageReport entity
const coverageReport = {
  id: `coverage-${Date.now()}`,
  timestamp: new Date(),
  totalLines: 0,
  coveredLines: 0,
  // ... calculate from coverageData
};

// Convert to FileCoverageDetail entities
Object.entries(coverageData).forEach(([filePath, coverage]) => {
  const fileCoverageDetail = {
    filePath,
    lines: coverage.s,
    branches: coverage.b,
    functions: coverage.f,
    // ... map remaining fields
  };
});
```

#### 3. ComponentUnderTest

**Generated By**: Custom analysis script + manual metadata

**File Mapping**:
```
ComponentUnderTest
  → Source files: src/components/**/*.js
  → Metadata file (custom): .specify/component-registry.json
  → TypeScript definitions: src/types/components.d.ts (if using TS)
  → PropTypes: Inline in component files
```

**Example Component Registry**:
```json
{
  "components": [
    {
      "name": "MusicalStaff",
      "filePath": "/src/components/musical/MusicalStaff.js",
      "type": "presentational",
      "isMusicalFeature": true,
      "musicalCapabilities": ["notation", "vexflow-rendering"],
      "isReusable": true,
      "isInCommonDirectory": false,
      "hasSingleResponsibility": true,
      "hasPropsDocumentation": true,
      "constitutionCompliance": {
        "Principle I": true,
        "Principle II": false,
        "Principle VI": false,
        "overallCompliant": false
      }
    }
  ]
}
```

**Script to Generate**:
```javascript
// scripts/generate-component-registry.js
// Scans src/components/ and generates component-registry.json
```

#### 4. AccessibilityViolation & AccessibilityAudit

**Generated By**: jest-axe (for integration tests), @axe-core/playwright (for E2E tests)

**File Mapping**:
```
AccessibilityAudit
  → Generated at: a11y-reports/audit-{timestamp}.json
  → HTML report: a11y-reports/audit-{timestamp}.html
  → Manual notes: a11y-reports/manual-audit-{timestamp}.md

AccessibilityViolation
  → Individual violations in audit JSON
  → Structure matches axe-core violation format
```

**Example Test**:
```javascript
// Integration test with jest-axe
import { axe, toHaveNoViolations } from 'jest-axe';
expect.extend(toHaveNoViolations);

test('ColorKey should have no accessibility violations', async () => {
  const { container } = render(<ColorKey />);
  const results = await axe(container);
  expect(results).toHaveNoViolations();

  // Save results to a11y-reports/
  fs.writeFileSync(
    `a11y-reports/color-key-${Date.now()}.json`,
    JSON.stringify(results, null, 2)
  );
});
```

```javascript
// E2E test with @axe-core/playwright
import { test, expect } from '@playwright/test';
import AxeBuilder from '@axe-core/playwright';

test('Full app should have no accessibility violations', async ({ page }) => {
  await page.goto('/');

  const accessibilityScanResults = await new AxeBuilder({ page })
    .withTags(['wcag2a', 'wcag2aa'])
    .analyze();

  expect(accessibilityScanResults.violations).toEqual([]);

  // Save results
  fs.writeFileSync(
    `a11y-reports/full-app-${Date.now()}.json`,
    JSON.stringify(accessibilityScanResults, null, 2)
  );
});
```

#### 5. PerformanceMetric

**Generated By**: Custom measurement in tests (using Performance API, Tone.js context)

**File Mapping**:
```
PerformanceMetric
  → Generated at: performance/metrics-{timestamp}.json
  → Per-component: performance/[component]-{timestamp}.json
  → CI artifacts: uploaded to GitHub Actions artifacts
```

**Example Measurement**:
```javascript
// Measure notation rendering time
test('MusicalStaff rendering should be < 200ms', async () => {
  const start = performance.now();
  const { container } = render(<MusicalStaff notes={...} />);
  const end = performance.now();

  const renderTime = end - start;

  const metric = {
    id: `perf-${Date.now()}`,
    metricType: "notation-rendering",
    measuredValue: renderTime,
    unit: "milliseconds",
    threshold: 200,
    isPassing: renderTime < 200,
    component: "MusicalStaff",
    measuredAt: new Date(),
    measuredBy: "browser.Performance API"
  };

  // Save to file
  fs.writeFileSync(
    `performance/musical-staff-${Date.now()}.json`,
    JSON.stringify(metric, null, 2)
  );

  expect(renderTime).toBeLessThan(200);
});

// Measure audio latency
test('Audio latency should be < 50ms', async () => {
  await Tone.start();
  const audioContext = Tone.context;

  const baseLatency = audioContext.baseLatency * 1000;
  const outputLatency = audioContext.outputLatency * 1000;
  const totalLatency = baseLatency + outputLatency;

  const metric = {
    id: `perf-${Date.now()}`,
    metricType: "audio-latency",
    measuredValue: totalLatency,
    unit: "milliseconds",
    threshold: 50,
    isPassing: totalLatency < 50,
    measuredBy: "Tone.js AudioContext"
  };

  // Save to file
  fs.writeFileSync(
    `performance/audio-latency-${Date.now()}.json`,
    JSON.stringify(metric, null, 2)
  );

  expect(totalLatency).toBeLessThan(50);
});
```

#### 6. TestConfiguration

**Stored In**: Configuration files

**File Mapping**:
```
TestConfiguration.jestConfig
  → jest.config.js or package.json "jest" section
  → Current: package.json lines 67-72

TestConfiguration.playwrightConfig
  → playwright.config.js or playwright.config.ts
  → Needs to be created

TestConfiguration.constitutionEnforcement
  → .specify/config/constitution-enforcement.json (custom)
  → Validated by CI script: .specify/scripts/validate-constitution.js
```

**Example Files**:
```javascript
// jest.config.js
module.exports = {
  testEnvironment: "jsdom",
  setupFilesAfterEnv: ["<rootDir>/src/setupTests.js"],
  coverageThresholds: {
    global: {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100
    }
  },
  collectCoverageFrom: [
    "src/**/*.{js,jsx}",
    "!src/index.js",
    "!src/__test__/**",
    "!src/__mocks__/**"
  ]
};
```

```javascript
// playwright.config.js
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  timeout: 30000,
  retries: 1,
  workers: 4,
  projects: [
    { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
    { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
    { name: 'webkit', use: { ...devices['Desktop Safari'] } },
  ],
  webServer: {
    command: 'npm start',
    port: 3000,
    reuseExistingServer: true,
  },
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    launchOptions: {
      args: [
        '--autoplay-policy=no-user-gesture-required',
        '--use-fake-device-for-media-stream',
      ],
      ignoreDefaultArgs: ['--mute-audio'],
    },
  },
});
```

```json
// .specify/config/constitution-enforcement.json
{
  "enforce100Coverage": true,
  "enforceIntegrationPercentage": true,
  "enforceE2EPercentage": true,
  "enforceUnitPercentage": true,
  "integrationTestRange": [60, 70],
  "e2eTestRange": [20, 30],
  "unitTestRange": [10, 20],
  "performanceThresholds": {
    "audioLatency": 50,
    "notationRendering": 200,
    "integrationTestTime": 5000,
    "e2eTestTime": 30000
  },
  "accessibilityThresholds": {
    "wcagLevel": "AA",
    "blockOnCritical": true,
    "blockOnSerious": true
  }
}
```

### CI/CD Integration

**GitHub Actions Workflow** (.github/workflows/ci.yml):
```yaml
name: Constitution Compliance CI

on:
  push:
    branches: [master, develop]
  pull_request:
    branches: [master]

jobs:
  test-and-validate:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Run integration tests with coverage
        run: npm run test-ci -- --coverage --testPathPattern=__integration__

      - name: Run unit tests with coverage
        run: npm run test-ci -- --coverage --testPathPattern=__test__

      - name: Run E2E tests
        run: npx playwright test

      - name: Run accessibility audit
        run: npm run test:a11y

      - name: Validate constitutional compliance
        run: node .specify/scripts/validate-constitution.js

      - name: Upload coverage reports
        uses: actions/upload-artifact@v3
        with:
          name: coverage-reports
          path: |
            coverage/
            playwright-report/
            a11y-reports/
            performance/

      - name: Fail if constitutional requirements not met
        run: |
          if [ -f .constitution-violations.json ]; then
            cat .constitution-violations.json
            exit 1
          fi
```

**Validation Script** (.specify/scripts/validate-constitution.js):
```javascript
const fs = require('fs');
const path = require('path');

// Read coverage report
const coverageReport = require('../../../coverage/coverage-final.json');

// Read test results
const jestResults = require('../../../test-results/jest-results.json');
const playwrightResults = require('../../../playwright-report/results.json');

// Read a11y audit
const a11yAudit = require('../../../a11y-reports/latest-audit.json');

// Read performance metrics
const perfMetrics = require('../../../performance/latest-metrics.json');

// Read constitution enforcement config
const config = require('../config/constitution-enforcement.json');

// Validate compliance
const violations = validateConstitutionalCompliance(
  coverageReport,
  jestResults,
  playwrightResults,
  a11yAudit,
  perfMetrics,
  config
);

if (violations.blockers.length > 0) {
  console.error('CONSTITUTIONAL VIOLATIONS DETECTED:');
  violations.blockers.forEach(v => console.error(`  - ${v}`));

  // Write violations to file for CI to detect
  fs.writeFileSync(
    '.constitution-violations.json',
    JSON.stringify(violations, null, 2)
  );

  process.exit(1);
}

console.log('✅ All constitutional requirements met!');
```

---

## Summary

This data model provides a comprehensive structure for implementing and enforcing Notio's Constitutional testing requirements. Key takeaways:

1. **9 Core Entities**: TestSuite, TestCase, CoverageReport, FileCoverageDetail, ComponentUnderTest, AccessibilityViolation, AccessibilityAudit, PerformanceMetric, TestConfiguration

2. **No Database Required**: All entities are runtime/file-system based, generated by test tools

3. **Constitutional Enforcement**: Validation rules map directly to Functional Requirements (FR-001 through FR-019) and Success Criteria (SC-001 through SC-014)

4. **CI/CD Integration**: Entities gate the CI/CD pipeline, ensuring 100% coverage, integration-first testing, accessibility compliance, and performance standards

5. **Practical Implementation**: Entities map to real test infrastructure files (Jest coverage, Playwright reports, axe-core results, performance measurements)

6. **State Transitions**: TestSuite, TestCase, AccessibilityViolation, and AccessibilityAudit have defined lifecycle state machines

7. **Cross-Entity Validation**: Complex validation rules span multiple entities to enforce constitutional compliance holistically

This data model serves as the foundation for Phase 2 (tasks.md generation) and Phase 3 (implementation), ensuring all test infrastructure work aligns with the Constitution's testing principles.
